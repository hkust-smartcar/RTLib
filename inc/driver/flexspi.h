/*
 * flexspi.h
 *
 *  Created on: Oct 6, 2018
 *      Author: LeeChunHei
 */

#ifndef INC_DRIVER_FLEXSPI_H_
#define INC_DRIVER_FLEXSPI_H_

#include "system/cmsis/access_layer/access_layer.h"
#include "system/pinout/pinout.h"

namespace Driver {

class FlexSpi {
public:
	struct Config {
		enum struct ReadSampleClock {
			kLoopbackInternally = 0x0U, /*!< Dummy Read strobe generated by FlexSPI Controller
			 and loopback internally. */
			kLoopbackFromDqsPad = 0x1U, /*!< Dummy Read strobe generated by FlexSPI Controller
			 and loopback from DQS pad. */
			kLoopbackFromSckPad = 0x2U, /*!< SCK output clock and loopback from SCK pad. */
			kExternalInputFromDqsPad = 0x3U, /*!< Flash provided Read strobe and input from DQS pad. */
		};
		struct AHBConfig {
			struct BufferConfig {
				uint8_t priority = 0; /*!< This priority for AHB Master Read which this AHB RX Buffer is assigned. */
				uint8_t master_index = 0; /*!< AHB Master ID the AHB RX Buffer is assigned. */
				uint16_t buffer_size = 256; /*!< AHB buffer size in byte. */
				bool enable_prefetch = false; /*!< AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master, allows
				 prefetch disable/enable seperately for each master. */
			};
			bool enable_AHB_write_ip_tx_fifo = false; /*!< Enable AHB bus write access to IP TX FIFO. */
			bool enable_AHB_write_ip_rx_fifo = false; /*!< Enable AHB bus write access to IP RX FIFO. */
			uint8_t ahb_grant_timeout_cycle = 0xFFU; /*!< Timeout wait cycle for AHB command grant,
			 timeout after ahbGrantTimeoutCyle*1024 AHB clock cycles. */
			uint16_t ahb_bus_timeout_cycle = 0xFFFFU; /*!< Timeout wait cycle for AHB read/write access,
			 timeout after ahbBusTimeoutCycle*1024 AHB clock cycles. */
			uint8_t resume_wait_cycle = 0x20U; /*!< Wait cycle for idle state before suspended command sequence
			 resume, timeout after ahbBusTimeoutCycle AHB clock cycles. */
			BufferConfig buffer[4] = { }; /*!< AHB buffer size. */
			bool enable_clear_AHB_buffer_opt = false; /*!< Enable/disable automatically clean AHB RX Buffer and TX Buffer
			 when FLEXSPI returns STOP mode ACK. */
			bool enable_read_address_opt = false; /*!< Enable/disable remove AHB read burst start address alignment limitation.
			 when eanble, there is no AHB read burst start address alignment limitation. */
			bool enable_AHB_prefetch = false; /*!< Enable/disable AHB read prefetch feature, when enabled, FLEXSPI
			 will fetch more data than current AHB burst. */
			bool enable_AHB_bufferable = false; /*!< Enable/disable AHB bufferable write access support, when enabled,
			 FLEXSPI return before waiting for command excution finished. */
			bool enable_AHB_cachable = false; /*!< Enable AHB bus cachable read access support. */
		};
		System::Pinout::Name sck;
		System::Pinout::Name cs;
		System::Pinout::Name sio[8] = { System::Pinout::Name::kDisable, System::Pinout::Name::kDisable, System::Pinout::Name::kDisable, System::Pinout::Name::kDisable, System::Pinout::Name::kDisable, System::Pinout::Name::kDisable, System::Pinout::Name::kDisable, System::Pinout::Name::kDisable };
		System::Pinout::Name dqs = System::Pinout::Name::kDisable;
		ReadSampleClock rx_sample_clock = ReadSampleClock::kLoopbackInternally; /*!< Sample Clock source selection for Flash Reading. */
		bool enable_sck_free_running = false; /*!< Enable/disable SCK output free-running. */
		bool enable_combination = false; /*!< Enable/disable combining PORT A and B Data Pins
		 (SIOA[3:0] and SIOB[3:0]) to support Flash Octal mode. */
		bool enable_doze = true; /*!< Enable/disable doze mode support. */
		bool enable_half_speed_access = false; /*!< Enable/disable divide by 2 of the clock for half
		 speed commands. */
		bool enable_sckB_diff_opt = false; /*!< Enable/disable SCKB pad use as SCKA differential clock
		 output, when enable, Port B flash access is not available. */
		bool enable_same_config_for_all = false; /*!< Enable/disable same configuration for all connected devices
		 when enabled, same configuration in FLASHA1CRx is applied to all. */
		uint16_t seq_timeout_cycle = 0xFFFFU; /*!< Timeout wait cycle for command sequence execution,
		 timeout after ahbGrantTimeoutCyle*1024 serial root clock cycles. */
		uint8_t ip_grant_timeout_cycle = 0xFFU; /*!< Timeout wait cycle for IP command grant, timeout after
		 ipGrantTimeoutCycle*1024 AHB clock cycles. */
		uint8_t tx_watermark = 8; /*!< FLEXSPI IP transmit watermark value. */
		uint8_t rx_watermark = 8; /*!< FLEXSPI receive watermark value. */
		AHBConfig ahb_config;
	};
	FlexSpi(const Config& config);
	struct FlashDeviceConfig {
		enum CsIntervalCycleUnit {
			k1SckCycle = 0x0U, /*!< Chip selection interval: CSINTERVAL * 1 serial clock cycle. */
			k256SckCycle = 0x1U, /*!< Chip selection interval: CSINTERVAL * 256 serial clock cycle. */
		};
		enum struct AHBWriteWaitUnit {
			k2AhbCycle = 0x0U, /*!< AWRWAIT unit is 2 ahb clock cycle. */
			k8AhbCycle = 0x1U, /*!< AWRWAIT unit is 8 ahb clock cycle. */
			k32AhbCycle = 0x2U, /*!< AWRWAIT unit is 32 ahb clock cycle. */
			k128AhbCycle = 0x3U, /*!< AWRWAIT unit is 128 ahb clock cycle. */
			k512AhbCycle = 0x4U, /*!< AWRWAIT unit is 512 ahb clock cycle. */
			k2048AhbCycle = 0x5U, /*!< AWRWAIT unit is 2048 ahb clock cycle. */
			k8192AhbCycle = 0x6U, /*!< AWRWAIT unit is 8192 ahb clock cycle. */
			k32768AhbCycle = 0x7U, /*!< AWRWAIT unit is 32768 ahb clock cycle. */
		};
		bool is_sck2_enabled; /*!< FLEXSPI use SCK2. */
		uint32_t flash_size; /*!< Flash size in KByte. */
		CsIntervalCycleUnit CS_interval_unit; /*!< CS interval unit, 1 or 256 cycle. */
		uint16_t CS_interval; /*!< CS line assert interval, mutiply CS interval unit to
		 get the CS line assert interval cycles. */
		uint8_t CS_hold_time; /*!< CS line hold time. */
		uint8_t CS_setup_time; /*!< CS line setup time. */
		uint8_t data_valid_time; /*!< Data valid time for external device. */
		uint8_t columnspace; /*!< Column space size. */
		bool enable_word_address; /*!< If enable word address.*/
		uint8_t AWR_seq_index; /*!< Sequence ID for AHB write command. */
		uint8_t AWR_seq_number; /*!< Sequence number for AHB write command. */
		uint8_t ARD_seq_index; /*!< Sequence ID for AHB read command. */
		uint8_t ARD_seq_number; /*!< Sequence number for AHB read command. */
		AHBWriteWaitUnit AHB_write_wait_unit; /*!< AHB write wait unit. */
		uint16_t AHB_write_wait_interval; /*!< AHB write wait interval, mutiply AHB write interval
		 unit to get the AHB write wait cycles. */
		bool enable_write_mask; /*!< Enable/Disable FLEXSPI drive DQS pin as write mask
		 when writing to external device. */
	};
	void SetFlashConfig(FlashDeviceConfig* config);
	/*! @brief CMD definition of FLEXSPI, use to form LUT instruction. */
	enum struct LUTCommand {
		kSTOP = 0x00U, /*!< Stop execution, deassert CS. */
		kSDR = 0x01U, /*!< Transmit Command code to Flash, using SDR mode. */
		kRADDR_SDR = 0x02U, /*!< Transmit Row Address to Flash, using SDR mode. */
		kCADDR_SDR = 0x03U, /*!< Transmit Column Address to Flash, using SDR mode. */
		kMODE1_SDR = 0x04U, /*!< Transmit 1-bit Mode bits to Flash, using SDR mode. */
		kMODE2_SDR = 0x05U, /*!< Transmit 2-bit Mode bits to Flash, using SDR mode. */
		kMODE4_SDR = 0x06U, /*!< Transmit 4-bit Mode bits to Flash, using SDR mode. */
		kMODE8_SDR = 0x07U, /*!< Transmit 8-bit Mode bits to Flash, using SDR mode. */
		kWRITE_SDR = 0x08U, /*!< Transmit Programming Data to Flash, using SDR mode. */
		kREAD_SDR = 0x09U, /*!< Receive Read Data from Flash, using SDR mode. */
		kLEARN_SDR = 0x0AU, /*!< Receive Read Data or Preamble bit from Flash, SDR mode. */
		kDATSZ_SDR = 0x0BU, /*!< Transmit Read/Program Data size (byte) to Flash, SDR mode. */
		kDUMMY_SDR = 0x0CU, /*!< Leave data lines undriven by FlexSPI controller.*/
		kDUMMY_RWDS_SDR = 0x0DU, /*!< Leave data lines undriven by FlexSPI controller,
		 dummy cycles decided by RWDS. */
		kDDR = 0x21U, /*!< Transmit Command code to Flash, using DDR mode. */
		kRADDR_DDR = 0x22U, /*!< Transmit Row Address to Flash, using DDR mode. */
		kCADDR_DDR = 0x23U, /*!< Transmit Column Address to Flash, using DDR mode. */
		kMODE1_DDR = 0x24U, /*!< Transmit 1-bit Mode bits to Flash, using DDR mode. */
		kMODE2_DDR = 0x25U, /*!< Transmit 2-bit Mode bits to Flash, using DDR mode. */
		kMODE4_DDR = 0x26U, /*!< Transmit 4-bit Mode bits to Flash, using DDR mode. */
		kMODE8_DDR = 0x27U, /*!< Transmit 8-bit Mode bits to Flash, using DDR mode. */
		kWRITE_DDR = 0x28U, /*!< Transmit Programming Data to Flash, using DDR mode. */
		kREAD_DDR = 0x29U, /*!< Receive Read Data from Flash, using DDR mode. */
		kLEARN_DDR = 0x2AU, /*!< Receive Read Data or Preamble bit from Flash, DDR mode. */
		kDATSZ_DDR = 0x2BU, /*!< Transmit Read/Program Data size (byte) to Flash, DDR mode. */
		kDUMMY_DDR = 0x2CU, /*!< Leave data lines undriven by FlexSPI controller.*/
		kDUMMY_RWDS_DDR = 0x2DU, /*!< Leave data lines undriven by FlexSPI controller,
		 dummy cycles decided by RWDS. */
		kJUMP_ON_CS = 0x1FU, /*!< Stop execution, deassert CS and save operand[7:0] as the
		 instruction start pointer for next sequence */
	};
	enum Pad {
		k1PAD = 0x00U, /*!< Transmit command/address and transmit/receive data only through DATA0/DATA1. */
		k2PAD = 0x01U, /*!< Transmit command/address and transmit/receive data only through DATA[1:0]. */
		k4PAD = 0x02U, /*!< Transmit command/address and transmit/receive data only through DATA[3:0]. */
		k8PAD = 0x03U, /*!< Transmit command/address and transmit/receive data only through DATA[7:0]. */
	};
	void UpdateLUT(uint32_t index, const uint32_t* cmd, uint32_t count);
	struct Transfer {
		enum struct CommandType {
			kCommand, /*!< FlexSPI operation: Only command, both TX and Rx buffer are ignored. */
			kConfig, /*!< FlexSPI operation: Configure device mode, the TX fifo size is fixed in LUT. */
			kRead, /* /!< FlexSPI operation: Read, only Rx Buffer is effective. */
			kWrite, /* /!< FlexSPI operation: Read, only Tx Buffer is effective. */
		};
		uint32_t device_address; /*!< Operation device address. */
		CommandType cmd_type; /*!< Execution command type. */
		uint8_t seq_index; /*!< Sequence ID for command. */
		uint8_t seq_number; /*!< Sequence number for command. */
		uint32_t* data; /*!< Data buffer. */
		uint32_t data_size; /*!< Data size in bytes. */
	};
	bool WriteBlocking(uint32_t* buffer, uint32_t size);
	bool ReadBlocking(uint32_t* buffer, uint32_t size);
	bool TransferBlocking(Transfer *xfer);

private:
	inline void Reset() {
		flexspi_base->MCR0 |= FLEXSPI_MCR0_SWRESET_MASK;
		while (flexspi_base->MCR0 & FLEXSPI_MCR0_SWRESET_MASK)
			;
	}
	inline bool GetBusIdleStatus() {
		return (flexspi_base->STS0 & FLEXSPI_STS0_ARBIDLE_MASK) && (flexspi_base->STS0 & FLEXSPI_STS0_SEQIDLE_MASK);
	}
	bool CheckAndClearError(uint32_t status);
	uint32_t ConfigureDll(FlashDeviceConfig* config);
	FLEXSPI_Type* flexspi_base;
	enum struct Port {
		kA1 = 0x0U, /*!< Access flash on A1 port. */
		kA2 = 0x1U, /*!< Access flash on A2 port. */
		kB1 = 0x2U, /*!< Access flash on B1 port. */
		kB2 = 0x3U, /*!< Access flash on B2 port. */
	};
	Port port;
};

}



#endif /* INC_DRIVER_FLEXSPI_H_ */
